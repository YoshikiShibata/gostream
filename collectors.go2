// Copyright Â© 2020 Yoshiki Shibata. All rights reserved.

package gostream

import (
	"fmt"
	"strings"
)

// ToSliceCollector returns a Collector for T.
func ToSliceCollector[T any]() *Collector[T, *[]T, []T] {
	return &Collector[T, *[]T, []T]{
		supplier: func() *[]T {
			var t []T
			return &t
		},
		accumulator: func(t1 *[]T, t2 T) {
			*t1 = append(*t1, t2)
		},
		combiner: func(left, right *[]T) *[]T {
			*left = append(*left, *right...)
			return left
		},
		finisher: func(t *[]T) []T {
			return *t
		},
	}
}

// ToSetCollector returns a Collector that accumulates the input elements
// into a new map[T]bool.
func ToSetCollector[T comparable]() *Collector[T, map[T]bool, map[T]bool] {
	return &Collector[T, map[T]bool, map[T]bool]{
		supplier: func() map[T]bool {
			return make(map[T]bool)
		},
		accumulator: func(m map[T]bool, k T) {
			m[k] = true
		},
		combiner: func(left, right map[T]bool) map[T]bool {
			for k := range right {
				left[k] = true
			}
			return left
		},
		finisher: func(t map[T]bool) map[T]bool {
			return t
		},
	}
}

// JoiningCollector returns a Collector that concatenates the input elements
// into a string, in encounter order.
func JoiningCollector(
	sep string,
) *Collector[string, *[]string, string] {
	return &Collector[string, *[]string, string]{
		supplier: func() *[]string {
			var s []string
			return &s
		},
		accumulator: func(b *[]string, s string) {
			*b = append(*b, s)
		},
		combiner: func(left, right *[]string) *[]string {
			*left = append(*left, *right...)
			return left
		},
		finisher: func(b *[]string) string {
			return strings.Join(*b, sep)
		},
	}
}

// MappingCollector adapts a Collector accepting elements of type U
// to one accepting elements of type T by appling a mapping function
// to each input element before accumulation.
func MappingCollector[T, U, A, R any](
	mapper Function[T, U],
	downstream *Collector[U, A, R]) *Collector[T, A, R] {
	downstreamAccumulator := downstream.Accumulator()

	return &Collector[T, A, R]{
		supplier: downstream.Supplier(),
		accumulator: func(r A, t T) {
			downstreamAccumulator(r, mapper(t))
		},
		combiner: downstream.Combiner(),
		finisher: downstream.Finisher(),
	}
}

// FlatMappingCollector adapts Collector accepting elements of type U to one
// accepting elements of type T by applying a flat mapping function to each
// input element before accumulation. The flat mapping function maps an input
// elements to a Stream covering zero or more output elements that are then
// accumulated downstream.
func FlatMappingCollector[T, U, A, R any](
	mapper Function[T, Stream[U]],
	downstream *Collector[U, A, R]) *Collector[T, A, R] {
	downstreamAccumulator := downstream.Accumulator()

	return &Collector[T, A, R]{
		supplier: downstream.Supplier(),
		accumulator: func(r A, t T) {
			mapper(t).ForEach(func(u U) {
				downstreamAccumulator(r, u)
			})
		},
		combiner: downstream.Combiner(),
		finisher: downstream.Finisher(),
	}
}

// FilteringCollector adapts a Collector to one accepting elements of the same
// type T by applying the predicate to each input element and only accumulating
// if the predicate returns true
func FilteringCollector[T, A, R any](
	predicate Predicate[T],
	downstream *Collector[T, A, R],
) *Collector[T, A, R] {
	downstreamAccumulator := downstream.Accumulator()

	return &Collector[T, A, R]{
		supplier: downstream.Supplier(),
		accumulator: func(r A, t T) {
			if predicate(t) {
				downstreamAccumulator(r, t)
			}
		},
		combiner: downstream.Combiner(),
		finisher: downstream.Finisher(),
	}
}

// GroupingByToSliceCollector returns a Collector implementing a "group by"
// operation on input elements of type T, grouping elements according to a
// classification function, and returning the results in a map.
//
// The classification function maps elements to some key type K.
// The collector produces a map[K][]T whoses keys are value resulting from
// applying the classification function to the input elements which map to
// the associated key under the classification function.
func GroupingByToSliceCollector[T any, K comparable](
	classifer Function[T, K],
) *Collector[T, map[K]*[]T, map[K][]T] {
	return GroupingByCollector(classifer, ToSliceCollector[T]())
}

// GroupingByCollector returns a Collector implementing a cascaded "group by"
// opertion on input elements of type T, grouping elements according to a
// classifier function, and then performing a reduction operation on the values
// associated with a give key using the specified downstream Collector.
func GroupingByCollector[T any, K comparable, A, D any](
	classifier Function[T, K],
	downstream *Collector[T, A, D],
) *Collector[T, map[K]A, map[K]D] {

	downstreamSupplier := downstream.Supplier()
	downstreamAccumulator := downstream.Accumulator()

	return &Collector[T, map[K]A, map[K]D]{
		supplier: func() map[K]A {
			return make(map[K]A)
		},
		accumulator: func(m map[K]A, t T) {
			key := classifier(t)
			a, ok := m[key]
			if !ok {
				a = downstreamSupplier()
				m[key] = a
			}
			downstreamAccumulator(a, t)
		},
		combiner: func(m1, m2 map[K]A) map[K]A {
			for k, a := range m2 {
				_, ok := m1[k]
				if ok {
					a = downstream.Combiner()(m1[k], a)
				}
				m1[k] = a
			}
			return m1
		},
		finisher: func(a map[K]A) map[K]D {
			result := make(map[K]D)
			for k, v := range a {
				result[k] = downstream.Finisher()(v)
			}
			return result
		},
	}
}

// PartitioningByToSliceCollector returns a Collector which partitions the
// input elements according to a Predicated, and organizes them into
// a map[bool][]T.
func PartitioningByToSliceCollector[T any](
	predicate Predicate[T],
) *Collector[T, *[2]*[]T, map[bool][]T] {
	return PartitioningByCollector(predicate, ToSliceCollector[T]())
}

// PartitioningByCollector returs a Collector which partitions the input
// elements according to a Predicate, reduces the values in each partition
// according to antoher Collector, and organizes them into map[bool]D whose
// values are the result of the downstream reducation.
func PartitioningByCollector[T, D, A any](
	predicate Predicate[T],
	downstream *Collector[T, A, D],
) *Collector[T, *[2]A, map[bool]D] {
	downstreamAccumulator := downstream.Accumulator()

	return &Collector[T, *[2]A, map[bool]D]{
		supplier: func() *[2]A {
			var partition [2]A
			partition[0] = downstream.Supplier()()
			partition[1] = downstream.Supplier()()
			return &partition
		},
		accumulator: func(partition *[2]A, t T) {
			if predicate(t) {
				downstreamAccumulator((*partition)[1], t) // true
			} else {
				downstreamAccumulator((*partition)[0], t) // false
			}
		},
		combiner: func(p1, p2 *[2]A) *[2]A {
			var partition [2]A

			partition[0] = downstream.Combiner()((*p1)[0], (*p2)[0])
			partition[1] = downstream.Combiner()((*p1)[1], (*p2)[1])
			return &partition
		},
		finisher: func(partition *[2]A) map[bool]D {
			result := make(map[bool]D)
			result[false] = downstream.Finisher()((*partition)[0])
			result[true] = downstream.Finisher()((*partition)[1])
			return result
		},
	}
}

// ToUniqueKeysMapCollector returns a Collector that accumulate elements into
// a map[K]U whose keys and values are the result of applying the provided
// mapping functions to the input elements.
//
// If the mapped keys contains duplicates, this function panics.
func ToUniqueKeysMapCollector[T any, K comparable, U any](
	keyMapper Function[T, K],
	valueMapper Function[T, U],
) *Collector[T, map[K]U, map[K]U] {
	return &Collector[T, map[K]U, map[K]U]{
		supplier: func() map[K]U {
			return make(map[K]U)
		},
		accumulator: func(m map[K]U, t T) {
			key := keyMapper(t)
			value := valueMapper(t)

			if _, ok := m[key]; ok {
				panic(fmt.Sprintf("duplicated key: %v", key))
			}
			m[key] = value
		},
		combiner: func(m1, m2 map[K]U) map[K]U {
			for key, v2 := range m2 {
				if _, ok := m1[key]; ok {
					panic(fmt.Sprintf("duplicated key: %v", key))
				}

				m1[key] = v2
			}
			return m1
		},
		finisher: func(m map[K]U) map[K]U {
			return m
		},
	}
}

// ToMapCollector returns a Collector that accumulates elements into a map[K]U
// whose keys and values are the result of applying the provided mapping
// functions to the input elements.
//
// If mapped keys contains duplicates, the value mapping function is applied
// to each equal element, and the results are merged using the provided
// merging function.
func ToMapCollector[T any, K comparable, U any](
	keyMapper Function[T, K],
	valueMapper Function[T, U],
	mergeFunction BinaryOperator[U],
) *Collector[T, map[K]U, map[K]U] {
	return &Collector[T, map[K]U, map[K]U]{
		supplier: func() map[K]U {
			return make(map[K]U)
		},
		accumulator: func(m map[K]U, t T) {
			key := keyMapper(t)
			value := valueMapper(t)

			v, ok := m[key]
			if ok {
				value = mergeFunction(v, value)
			}
			m[key] = value
		},
		combiner: func(m1, m2 map[K]U) map[K]U {
			for key, v2 := range m2 {
				var value U

				v1, ok := m1[key]
				if ok {
					value = mergeFunction(v1, v2)
				} else {
					value = v2
				}
				m1[key] = value
			}
			return m1
		},
		finisher: func(m map[K]U) map[K]U {
			return m
		},
	}
}

// SummarizingCollector returns a Collector which applies an
// number-producing mapping function to each input element, and returns summary
// statistics for the resulting values.
func SummarizingCollector[T any, R Number](
	mapper Function[T, R],
) *Collector[T, *SummaryStatistics[R], *SummaryStatistics[R]] {
	return &Collector[T, *SummaryStatistics[R], *SummaryStatistics[R]]{
		supplier: NewSummaryStatistics[R],
		accumulator: func(i *SummaryStatistics[R], t T) {
			i.accept(mapper(t))
		},
		combiner: func(l *SummaryStatistics[R],
			r *SummaryStatistics[R],
		) *SummaryStatistics[R] {
			l.combine(r)
			return l
		},
		finisher: func(i *SummaryStatistics[R]) *SummaryStatistics[R] {
			return i
		},
	}
}

// SummingCollector returns a Collector that produces the sum of a 
// number-valued function applied to the input elements. If no elements are 
// present, the result is 0.
func SummingCollector[T any, R Number](
	mapper Function[T, R],
) *Collector[T, *R, R] {
	return &Collector[T, *R, R]{
		supplier: func() *R {
			return new(R)
		},
		accumulator: func(a *R, t T) {
			*a += mapper(t)
		},
		combiner: func(a, b *R) *R {
			*a += *b
			return a
		},
		finisher: func(a *R) R {
			return *a
		},
	}
}
