// Copyright Â© 2020 Yoshiki Shibata. All rights reserved.

package gostream

import (
	"fmt"
)

// Map returns a stream consisting of the results of applying the given
// function to the elements of the given stream.
func Map[type T, R any](stream Stream[T], mapper Function[T, R]) Stream[R] {
	var gs *genericStream[T]

	switch s := stream.(type) {
	case *genericStream[T]:
		gs = s
	default:
		panic(fmt.Sprintf("Unsupported Type: %T", stream))
	}

	nextReq := make(chan struct{})
	nextData := make(chan R)

	go func() {
		for range nextReq {
			gs.nextReq <- struct{}{}
			t, ok := <-gs.nextData
			if !ok {
				close(nextData)
				close(gs.nextReq)
				go func() {
					for range nextReq {
					}
				}()
				return
			}
			r := mapper(t)
			nextData <- r
		}
	}()

	return &genericStream[R]{
		nextReq:  nextReq,
		nextData: nextData,
	}
}

// FlatMap returns a stream consisting of the results of replacing each
// element of stream with the contents of mapped stream produced by applying
// the provided mapping function to each element.
func FlatMap[type T, R](
	stream Stream[T],
	mapper Function[T, Stream[R]],
) Stream[R] {
	panic("not implemented yet")
}
