// Copyright Â© 2020 Yoshiki Shibata. All rights reserved.

package gostream

import (
	"fmt"
	"sort"
)

type genericStream[type T any] struct {
	prevReq  chan struct{}
	prevData chan T
	nextReq  chan struct{}
	nextData chan T
}

func newGenericStream[type T any](gs *genericStream[T]) *genericStream[T] {
	return &genericStream[T]{
		prevReq:  gs.nextReq,
		prevData: gs.nextData,
		nextReq:  make(chan struct{}),
		nextData: make(chan T),
	}
}

func (gs *genericStream[T]) discard(c <-chan struct{}) {
	go func() {
		for range c {
		}
	}()
}

func (gs *genericStream[T]) close() {
	close(gs.nextData)
	close(gs.prevReq)
	gs.discard(gs.nextReq)
}

func (gs *genericStream[T]) getPrevData() (T, bool) {
	gs.prevReq <- struct{}{}
	data, ok := <-gs.prevData
	return data, ok
}

func (gs *genericStream[T]) terminalOp(op Consumer[T]) {
	gs.nextReq <- struct{}{}
	for t := range gs.nextData {
		op(t)
		gs.nextReq <- struct{}{}
	}
}

func (gs *genericStream[T]) Filter(predicate Predicate[T]) Stream[T] {
	newGS := newGenericStream(gs)

	go newGS.filter(predicate)
	return newGS
}

func (gs *genericStream[T]) filter(predicate Predicate[T]) {
	for range gs.nextReq {
		data, ok := gs.getPrevData()
		if !ok {
			gs.close()
			return
		}

		for !predicate(data) {
			data, ok = gs.getPrevData()
			if !ok {
				gs.close()
				return
			}
		}
		gs.nextData <- data
	}

	gs.close()
}

func (gs *genericStream[T]) ForEach(action Consumer[T]) {
	gs.terminalOp(action)
}

func (gs *genericStream[T]) Sorted(less Less[T]) Stream[T] {
	var dataSlice []T

	gs.terminalOp(func(t T) {
		dataSlice = append(dataSlice, t)
	})

	sort.Slice(dataSlice, func(i, j int) bool {
		return less(dataSlice[i], dataSlice[j])
	})

	return StreamFromSlice(dataSlice)
}

func (gs *genericStream[T]) Peek(action Consumer[T]) Stream[T] {
	newGS := newGenericStream(gs)

	go newGS.peek(action)
	return newGS
}

func (gs *genericStream[T]) peek(action Consumer[T]) {
	for range gs.nextReq {
		data, ok := gs.getPrevData()
		if !ok {
			gs.close()
			return
		}
		action(data)
		gs.nextData <- data
	}
	gs.close()
}

func (gs *genericStream[T]) Limit(maxSize int) Stream[T] {
	newGS := newGenericStream(gs)

	go newGS.limit(maxSize)
	return newGS
}

func (gs *genericStream[T]) limit(maxSize int) {
	if maxSize < 0 {
		panic(fmt.Sprintf("maxSize must not be negative: %v", maxSize))
	}
	if maxSize == 0 {
		gs.close()
		return
	}

	count := maxSize
	for range gs.nextReq {
		data, ok := gs.getPrevData()
		if !ok {
			gs.close()
			return
		}
		gs.nextData <- data
		count--
		if count == 0 {
			gs.close()
			return
		}
	}
	gs.close()
}

func (gs *genericStream[T]) Skip(n int) Stream[T] {
	newGS := newGenericStream(gs)

	go newGS.skip(n)
	return newGS
}

func (gs *genericStream[T]) skip(n int) {
	for range gs.nextReq {
		// Skip n elements
		for n > 0 {
			_, ok := gs.getPrevData()
			if !ok {
				gs.close()
				return
			}
			n--
		}

		data, ok := gs.getPrevData()
		if !ok {
			gs.close()
			return
		}
		gs.nextData <- data
	}

	gs.close()
}

func (gs *genericStream[T]) ToSlice() []T {
	var result []T

	gs.terminalOp(func(t T) {
		result = append(result, t)
	})

	return result
}

func (gs *genericStream[T]) Reduce(
	identity T,
	accumulator BinaryOperator[T],
) T {
	result := identity

	gs.terminalOp(func(t T) {
		result = accumulator(result, t)
	})

	return result
}

func (gs *genericStream[T]) Count() int {
	count := 0

	gs.terminalOp(func(t T) { count++ })

	return count
}
