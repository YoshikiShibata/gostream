// Copyright Â© 2020 Yoshiki Shibata. All rights reserved.

package gostream

import (
	"fmt"
	"runtime"
	"sort"
	"sync"
)

type orderedData[T any] struct {
	order uint64
	data  T
}

type genericStream[T any] struct {
	lock          sync.Mutex
	closed        bool
	parallel      bool
	parallelCount int

	prevReq  chan struct{}
	prevData chan orderedData[T]
	nextReq  chan struct{}
	nextData chan orderedData[T]
}

var (
	goMaxProcs = runtime.GOMAXPROCS(-1)
)

func newGenericStream[T any](gs *genericStream[T]) *genericStream[T] {
	return &genericStream[T]{
		parallel:      gs.parallel,
		parallelCount: gs.parallelCount,
		prevReq:       gs.nextReq,
		prevData:      gs.nextData,
		nextReq:       make(chan struct{}),
		nextData:      make(chan orderedData[T]),
	}
}

func (gs *genericStream[T]) validateState() {
	gs.lock.Lock()
	defer gs.lock.Unlock()

	if gs.closed {
		panic("stream has already been closed")
	}
}
func (gs *genericStream[T]) discard(c <-chan struct{}) {
	go func() {
		for range c {
		}
	}()
}

func (gs *genericStream[T]) close() {
	gs.lock.Lock()
	defer gs.lock.Unlock()

	if gs.closed {
		return
	}

	if gs.parallelCount > 1 {
		gs.parallelCount--
		return
	}

	fmt.Println("DEBUG Close")
	close(gs.nextData)
	close(gs.prevReq)
	gs.discard(gs.nextReq)

	gs.closed = true
}

func (gs *genericStream[T]) terminalClose() {
	gs.lock.Lock()
	defer gs.lock.Unlock()

	if gs.closed {
		return
	}

	if gs.parallelCount > 1 {
		gs.parallelCount--
		return
	}

	close(gs.nextReq)
	gs.closed = true
}

func (gs *genericStream[T]) getPrevData() (orderedData[T], bool) {
	gs.prevReq <- struct{}{}
	data, ok := <-gs.prevData
	return data, ok
}

func (gs *genericStream[T]) terminalOp(op Consumer[T]) {
	gs.nextReq <- struct{}{}
	for od := range gs.nextData {
		op(od.data)
		gs.nextReq <- struct{}{}
	}
	gs.terminalClose()
}

func (gs *genericStream[T]) terminalOpOrderedData(
	op Consumer[orderedData[T]]) {
	gs.nextReq <- struct{}{}
	for od := range gs.nextData {
		op(od)
		gs.nextReq <- struct{}{}
	}

	gs.terminalClose()
}

func (gs *genericStream[T]) terminalOpMatch(match func(t T) bool) {
	gs.nextReq <- struct{}{}
	for od := range gs.nextData {
		if !match(od.data) {
			break
		}
		gs.nextReq <- struct{}{}
	}

	gs.terminalClose()
}

func (gs *genericStream[T]) Parallel() Stream[T] {
	gs.validateState()

	if gs.parallel {
		return gs
	}

	newGS := newGenericStream(gs)
	newGS.parallel = true
	newGS.parallelCount = goMaxProcs

	for i := 0; i < newGS.parallelCount; i++ {
		go newGS.drain()
	}

	return newGS
}

func (gs *genericStream[T]) drain() {
	for range gs.nextReq {
		data, ok := gs.getPrevData()
		if !ok {
			gs.close()
			return
		}
		gs.nextData <- data
	}
	gs.close()
}

func (gs *genericStream[T]) Filter(predicate Predicate[T]) Stream[T] {
	gs.validateState()

	newGS := newGenericStream(gs)

	parallelCount := gs.parallelCount
	for i := 0; i < parallelCount; i++ {
		go newGS.filter(predicate)
	}
	return newGS
}

func (gs *genericStream[T]) filter(predicate Predicate[T]) {
	for range gs.nextReq {
		od, ok := gs.getPrevData()
		if !ok {
			gs.close()
			return
		}

		for !predicate(od.data) {
			od, ok = gs.getPrevData()
			if !ok {
				gs.close()
				return
			}
		}
		gs.nextData <- od
	}

	gs.close()
}

func (gs *genericStream[T]) Close() {
	gs.validateState()

	panic("Not Implemented Yet")
}

func (gs *genericStream[T]) ForEach(action Consumer[T]) {
	gs.validateState()

	if !gs.parallel {
		gs.terminalOp(action)
		return
	}

	var wg sync.WaitGroup

	parallelCount := gs.parallelCount
	for i := 0; i < parallelCount; i++ {
		wg.Add(1)
		go func() {
			gs.terminalOp(action)
			wg.Done()
		}()
	}
	wg.Wait()
}

func (gs *genericStream[T]) Sorted(less Less[T]) Stream[T] {
	gs.validateState()

	var dataSlice []T

	if !gs.parallel {
		gs.terminalOp(func(t T) {
			dataSlice = append(dataSlice, t)
		})
	} else {
		slices := make(chan []T)

		parallelCount := gs.parallelCount
		for i := 0; i < parallelCount; i++ {
			go func() {
				var slice []T

				gs.terminalOp(func(t T) {
					slice = append(slice, t)
				})

				slices <- slice
			}()
		}

		for i := 0; i < parallelCount; i++ {
			slice := <-slices
			dataSlice = append(dataSlice, slice...)
		}
	}

	sort.Slice(dataSlice, func(i, j int) bool {
		return less(dataSlice[i], dataSlice[j])
	})

	return Of(dataSlice...)
}

func (gs *genericStream[T]) Peek(action Consumer[T]) Stream[T] {
	gs.validateState()

	newGS := newGenericStream(gs)

	go newGS.peek(action)
	return newGS
}

func (gs *genericStream[T]) peek(action Consumer[T]) {
	for range gs.nextReq {
		od, ok := gs.getPrevData()
		if !ok {
			gs.close()
			return
		}
		action(od.data)
		gs.nextData <- od
	}
	gs.close()
}

func (gs *genericStream[T]) Limit(maxSize int) Stream[T] {
	gs.validateState()

	newGS := newGenericStream(gs)

	go newGS.limit(maxSize)
	return newGS
}

func (gs *genericStream[T]) limit(maxSize int) {
	if maxSize < 0 {
		panic(fmt.Sprintf("maxSize must not be negative: %v", maxSize))
	}
	if maxSize == 0 {
		gs.close()
		return
	}

	count := maxSize
	for range gs.nextReq {
		data, ok := gs.getPrevData()
		if !ok {
			gs.close()
			return
		}
		gs.nextData <- data
		count--
		if count == 0 {
			gs.close()
			return
		}
	}
	gs.close()
}

func (gs *genericStream[T]) Skip(n int) Stream[T] {
	gs.validateState()

	newGS := newGenericStream(gs)

	go newGS.skip(n)
	return newGS
}

func (gs *genericStream[T]) skip(n int) {
	for range gs.nextReq {
		// Skip n elements
		for n > 0 {
			_, ok := gs.getPrevData()
			if !ok {
				gs.close()
				return
			}
			n--
		}

		data, ok := gs.getPrevData()
		if !ok {
			gs.close()
			return
		}
		gs.nextData <- data
	}

	gs.close()
}

func (gs *genericStream[T]) ToSlice() []T {
	gs.validateState()

	if !gs.parallel {
		var result []T
		gs.terminalOp(func(t T) {
			result = append(result, t)
		})
		return result
	}

	results := make(chan []orderedData[T])

	// collect in parallel
	parallelCount := gs.parallelCount
	for i := 0; i < parallelCount; i++ {
		go func() {
			var ods []orderedData[T]

			gs.terminalOpOrderedData(func(od orderedData[T]) {
				ods = append(ods, od)
			})

			results <- ods
		}()
	}

	// combine all results
	var ods []orderedData[T]
	for i := 0; i < parallelCount; i++ {
		result := <-results
		ods = append(ods, result...)
	}
	close(results)

	// sort
	sort.Slice(ods, func(i, j int) bool {
		return ods[i].order < ods[j].order
	})

	// copy sorted result to []T
	result := make([]T, len(ods))
	for i := 0; i < len(ods); i++ {
		result[i] = ods[i].data
	}

	return result
}

func (gs *genericStream[T]) Reduce(
	identity T,
	accumulator BinaryOperator[T],
) T {
	gs.validateState()

	result := identity

	gs.terminalOp(func(t T) {
		result = accumulator(result, t)
	})

	return result
}

func (gs *genericStream[T]) ReduceToOptional(
	accumulator BinaryOperator[T],
) *Optional[T] {
	gs.validateState()

	foundAny := false
	var result T

	gs.terminalOp(func(t T) {
		if !foundAny {
			foundAny = true
			result = t
		} else {
			result = accumulator(result, t)
		}
	})

	if foundAny {
		return OptionalOf(result)
	}
	return OptionalEmpty[T]()
}

func (gs *genericStream[T]) Min(less Less[T]) *Optional[T] {
	gs.validateState()

	foundAny := false
	var result T

	gs.terminalOp(func(t T) {
		if !foundAny {
			foundAny = true
			result = t
		} else if less(t, result) {
			result = t
		}
	})

	if foundAny {
		return OptionalOf(result)
	}
	return OptionalEmpty[T]()
}

func (gs *genericStream[T]) Max(less Less[T]) *Optional[T] {
	gs.validateState()

	foundAny := false
	var result T

	gs.terminalOp(func(t T) {
		if !foundAny {
			foundAny = true
			result = t
		} else if less(result, t) {
			result = t
		}
	})

	if foundAny {
		return OptionalOf(result)
	}
	return OptionalEmpty[T]()
}

func (gs *genericStream[T]) Count() int {
	gs.validateState()

	count := 0

	gs.terminalOp(func(t T) { count++ })

	return count
}

func (gs *genericStream[T]) AnyMatch(predicate Predicate[T]) bool {
	gs.validateState()

	match := false

	gs.terminalOpMatch(func(t T) bool {
		if !predicate(t) {
			return true // continue
		}

		match = true
		return false
	})

	return match
}

func (gs *genericStream[T]) AllMatch(predicate Predicate[T]) bool {
	gs.validateState()

	match := true

	gs.terminalOpMatch(func(t T) bool {
		if predicate(t) {
			return true // contine
		}
		match = false
		return false
	})

	return match
}

func (gs *genericStream[T]) NoneMatch(predicate Predicate[T]) bool {
	gs.validateState()

	noneMatch := true

	gs.terminalOpMatch(func(t T) bool {
		if !predicate(t) {
			return true // continue
		}
		noneMatch = false
		return false
	})

	return noneMatch
}

func (gs *genericStream[T]) FindFirst() *Optional[T] {
	gs.validateState()

	foundAny := false
	var result T

	gs.terminalOpMatch(func(t T) bool {
		foundAny = true
		result = t

		return false
	})

	if foundAny {
		return OptionalOf(result)
	}
	return OptionalEmpty[T]()
}
