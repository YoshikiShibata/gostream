// Copyright Â© 2020 Yoshiki Shibata. All rights reserved.

package gostream

type genericStream(type T) struct {
	prevReq  chan struct{}
	prevData chan T
	nextReq  chan struct{}
	nextData chan T
}

func (gs *genericStream(T)) Filter(predicate Predicate(T)) Stream(T) {
	newGS := &genericStream(T){
		prevReq:  gs.nextReq,
		prevData: gs.nextData,
		nextReq:  make(chan struct{}),
		nextData: make(chan T),
	}

	go newGS.filter(predicate)

	return newGS
}

func (gs *genericStream(T)) Distinct() Stream(T) {
	newGS := &genericStream(T){
		prevReq:  gs.nextReq,
		prevData: gs.nextData,
		nextReq:  make(chan struct{}),
		nextData: make(chan T),
	}

	go newGS.distinct()

	return newGS
}

func (gs *genericStream(T)) filter(predicate Predicate(T)) {
	for range gs.nextReq {
		gs.prevReq <- struct{}{}
		data, ok := <-gs.prevData
		if !ok {
			close(gs.nextData)
			close(gs.prevReq)
			return
		}

		for !predicate(data) {
			gs.prevReq <- struct{}{}
			data, ok = <-gs.prevData
			if !ok {
				close(gs.nextData)
				close(gs.prevReq)
				return
			}
		}
		gs.nextData <- data
	}
}

func (gs *genericStream(T)) distinct() {
	seen := make(map[T]bool)
	
	for range gs.nextReq {
		gs.prevReq <- struct{}{}
		data, ok := <-gs.prevData
		if !ok {
			close(gs.nextData)
			close(gs.prevReq)
			return
		}

		for seen[data] {
			gs.prevReq <- struct{}{}
			data, ok = <-gs.prevData
			if !ok {
				close(gs.nextData)
				close(gs.prevReq)
				return
			}
		}
		gs.nextData <- data
		seen[data] = true
	}
}

func (gs *genericStream(T)) ForEach(action Consumer(T)) {
	gs.nextReq <- struct{}{}
	for t := range gs.nextData {
		action(t)
		gs.nextReq <- struct{}{}
	}
}
