// Copyright Â© 2020 Yoshiki Shibata. All rights reserved.

package gostream

import (
	"fmt"
	"sort"
)

type genericStream[type T] struct {
	prevReq  chan struct{}
	prevData chan T
	nextReq  chan struct{}
	nextData chan T
}

func (gs *genericStream[T]) discard(c chan struct{}) {
	go func() {
		for range c {
		}
	}()
}

func (gs *genericStream[T]) Filter(predicate Predicate[T]) Stream[T] {
	newGS := &genericStream[T]{
		prevReq:  gs.nextReq,
		prevData: gs.nextData,
		nextReq:  make(chan struct{}),
		nextData: make(chan T),
	}

	go newGS.filter(predicate)

	return newGS
}

func (gs *genericStream[T]) filter(predicate Predicate[T]) {
	for range gs.nextReq {
		gs.prevReq <- struct{}{}
		data, ok := <-gs.prevData
		if !ok {
			close(gs.nextData)
			close(gs.prevReq)
			gs.discard(gs.nextReq)
			return
		}

		for !predicate(data) {
			gs.prevReq <- struct{}{}
			data, ok = <-gs.prevData
			if !ok {
				close(gs.nextData)
				close(gs.prevReq)
				gs.discard(gs.nextReq)
				return
			}
		}
		gs.nextData <- data
	}

	close(gs.nextData)
	close(gs.prevReq)
}

func (gs *genericStream[T]) ForEach(action Consumer[T]) {
	gs.nextReq <- struct{}{}
	for t := range gs.nextData {
		action(t)
		gs.nextReq <- struct{}{}
	}
}

func (gs *genericStream[T]) Sorted(less Less[T]) Stream[T] {
	var dataSlice []T

	gs.nextReq <- struct{}{}
	for t := range gs.nextData {
		dataSlice = append(dataSlice, t)
		gs.nextReq <- struct{}{}
	}
	sort.Slice(dataSlice, func(i, j int) bool {
		return less(dataSlice[i], dataSlice[j])
	})

	return newSliceStreamImpl(dataSlice)
}

func (gs *genericStream[T]) Peek(action Consumer[T]) Stream[T] {
	panic("Not Implemented Yet")
}

func (gs *genericStream[T]) Limit(maxSize int) Stream[T] {
	newGS := &genericStream[T]{
		prevReq:  gs.nextReq,
		prevData: gs.nextData,
		nextReq:  make(chan struct{}),
		nextData: make(chan T),
	}

	go newGS.limit(maxSize)

	return newGS
}

func (gs *genericStream[T]) limit(maxSize int) {
	if maxSize < 0 {
		panic(fmt.Sprintf("maxSize must not be negative: %v", maxSize))
	}
	if maxSize == 0 {
		close(gs.nextData)
		close(gs.prevReq)
		gs.discard(gs.nextReq)
		return
	}

	count := maxSize
	for range gs.nextReq {
		gs.prevReq <- struct{}{}
		data, ok := <-gs.prevData
		if !ok {
			close(gs.nextData)
			close(gs.prevReq)
			gs.discard(gs.nextReq)
			return
		}
		gs.nextData <- data
		count--
		if count == 0 {
			close(gs.nextData)
			close(gs.prevReq)
			gs.discard(gs.nextReq)
			return
		}
	}
	close(gs.nextData)
	close(gs.prevReq)
}
