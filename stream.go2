// Copyright Â© 2020 Yoshiki Shibata. All rights reserved.

package gostream

import (
	"constraints"
	"fmt"
	"sort"
)

type Consumer[type T] func(t T)
type Predicate[type T] func(t T) bool
type Function[type T, R] func(t T) R
type Less[type T] func(t1, t2 T) bool
type BiFunction[type T, U, R] func(t T, u U) R
type BinaryOperator[type T] BiFunction[T, T, T]

type Stream[type T] interface {
	// Filter returns a stream consisting of the elements of this stream
	// that mathe the give predicate.
	Filter(predicate Predicate[T]) Stream[T]

	// ForEach performs an action for each element of this stream.
	ForEach(action Consumer[T])

	// Sorted returns a stream consisting of the elements of this stream,
	// according to the provided Less.
	Sorted(less Less[T]) Stream[T]

	// Peek returns a stream consisting of the elements of this stream,
	// additionally performing the provided action on each element as elements
	// are consumed from the resulting steam.
	Peek(action Consumer[T]) Stream[T]

	// Limit returns a stream consisting of the elements of this stream,
	// truncated to be no logner than maxSize in length.
	Limit(maxSize int) Stream[T]

	// Skip(n int) Stream[T]
	// ToSlice() []T
	// Reduce(identity T, accumulator BinaryOperator[T] T
	// Count() int
}

// Distinct returns a stream consisting of the distinct elements
// (according to ==) of this stream.
func Distinct[type T comparable](stream Stream[T]) Stream[T] {
	var gs *genericStream[T]
	switch s := stream.(type) {
	case *sliceStream[T]:
		gs = &genericStream[T]{
			prevReq:  s.nextReq,
			prevData: s.nextData,
			nextReq:  make(chan struct{}),
			nextData: make(chan T),
		}
	case *genericStream[T]:
		gs = &genericStream[T]{
			prevReq:  s.nextReq,
			prevData: s.nextData,
			nextReq:  make(chan struct{}),
			nextData: make(chan T),
		}
	case *mapStream[T]:
		gs = &genericStream[T]{
			prevReq:  s.nextReq,
			prevData: s.nextData,
			nextReq:  make(chan struct{}),
			nextData: make(chan T),
		}
	default:
		panic(fmt.Sprintf("%T is not supported yet", stream))
	}

	go func() {
		seen := make(map[T]bool)

		for range gs.nextReq {
			gs.prevReq <- struct{}{}
			data, ok := <-gs.prevData
			if !ok {
				close(gs.nextData)
				close(gs.prevReq)
				return
			}

			for seen[data] {
				gs.prevReq <- struct{}{}
				data, ok = <-gs.prevData
				if !ok {
					close(gs.nextData)
					close(gs.prevReq)
					return
				}
			}
			gs.nextData <- data
			seen[data] = true
		}
	}()

	return gs
}

// Sorted returns a stream consisting of the elements of stream, sorted
// according to natural order.
func Sorted[type T constraints.Ordered](stream Stream[T]) Stream[T] {
	var prevReq chan struct{}
	var prevData chan T

	switch s := stream.(type) {
	case *sliceStream[T]:
		prevReq = s.nextReq
		prevData = s.nextData
	case *genericStream[T]:
		prevReq = s.nextReq
		prevData = s.nextData
	case *mapStream[T]:
		prevReq = s.nextReq
		prevData = s.nextData
	default:
		panic(fmt.Sprintf("%T is not supported yet", stream))
	}

	var dataSlice []T
	for {
		prevReq <- struct{}{}
		data, ok := <-prevData
		if !ok {
			break
		}
		dataSlice = append(dataSlice, data)
	}
	sort.Slice(dataSlice, func(i, j int) bool {
		return dataSlice[i] < dataSlice[j]
	})

	return newSliceStreamImpl(dataSlice)
	// Somehow following line cannot be compiled.
	// retun StreamFromSlice(dataSlice)
}
