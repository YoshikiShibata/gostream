package gostream

type Consumer(type T) func(t T)
type Predicate(type T) func(t T) bool

type Stream(type T) interface {
	// ForEach performs an action for each element of this stream.
	ForEach(action Consumer(T))

	Filter(predicate Predicate(T)) Stream(T)
}

type sliceStreamImpl(type T) struct {
	data        []T
	dataRequest chan struct{}
	dataChan    chan T
}

func newSliceStreamImpl(type T)(data []T) *sliceStreamImpl(T) {
	ssImpl := &sliceStreamImpl(T){
		data:        data,
		dataRequest: make(chan struct{}),
		dataChan:    make(chan T),
	}
	go func() {
		i := 0
		for range ssImpl.dataRequest {
			if i == len(ssImpl.data) {
				close(ssImpl.dataChan)
				return
			}
			if i < len(ssImpl.data) {
				ssImpl.dataChan <- ssImpl.data[i]
				i++
			}
		}
		close(ssImpl.dataChan)
	}()

	return ssImpl
}

type genericStreamImpl(type T) struct {
	prevDataRequest chan struct{}
	prevDataChan    chan T
	nextDataRequest chan struct{}
	nextDataChan    chan T
}

func (ssImpl *sliceStreamImpl(T)) Filter(predicate Predicate(T)) Stream(T) {
	gsImpl := &genericStreamImpl(T){
		prevDataRequest: ssImpl.dataRequest,
		prevDataChan:    ssImpl.dataChan,
		nextDataRequest: make(chan struct{}),
		nextDataChan:    make(chan T),
	}
	go gsImpl.filter(predicate)

	return gsImpl
}

func (ssImpl *sliceStreamImpl(T)) ForEach(action Consumer(T)) {
	ssImpl.dataRequest <- struct{}{}
	for t := range ssImpl.dataChan {
		action(t)
		ssImpl.dataRequest <- struct{}{}
	}
}

func (gsImpl *genericStreamImpl(T)) Filter(predicate Predicate(T)) Stream(T) {
	gsImpl2 := &genericStreamImpl(T){
		prevDataRequest: gsImpl.nextDataRequest,
		prevDataChan:    gsImpl.nextDataChan,
		nextDataRequest: make(chan struct{}),
		nextDataChan:    make(chan T),
	}

	go gsImpl2.filter(predicate)

	return gsImpl2
}

func (gsImpl *genericStreamImpl(T)) filter(predicate Predicate(T)) {
	for range gsImpl.nextDataRequest {
		gsImpl.prevDataRequest <- struct{}{}
		data, ok := <-gsImpl.prevDataChan
		if !ok {
			close(gsImpl.nextDataChan)
			close(gsImpl.prevDataRequest)
			return
		}

		for !predicate(data) {
			gsImpl.prevDataRequest <- struct{}{}
			data, ok = <-gsImpl.prevDataChan
			if !ok {
				close(gsImpl.nextDataChan)
				close(gsImpl.prevDataRequest)
				return
			}
		}
		gsImpl.nextDataChan <- data
	}
}

func (gsImpl *genericStreamImpl(T)) ForEach(action Consumer(T)) {
	gsImpl.nextDataRequest <- struct{}{}
	for t := range gsImpl.nextDataChan {
		action(t)
		gsImpl.nextDataRequest <- struct{}{}
	}
}

func AsStream(type T)(slice []T) Stream(T) {
	return newSliceStreamImpl(slice)
}
