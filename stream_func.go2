// Copyright Â© 2020 Yoshiki Shibata. All rights reserved.

package gostream

import (
	"constraints"
	"runtime"
	"sort"
	"sync"
)

// Distinct returns a stream consisting of the distinct elements
// (according to ==) of this stream.
func Distinct[type T comparable](stream Stream[T]) Stream[T] {
	s, ok := stream.(*genericStream[T])
	if !ok {
		panic("type assertion failed")
	}

	gs := &genericStream[T]{
		prevReq:  s.nextReq,
		prevData: s.nextData,
		nextReq:  make(chan struct{}),
		nextData: make(chan T),
	}

	go func() {
		seen := make(map[T]bool)

		for range gs.nextReq {
			data, ok := gs.getPrevData()
			if !ok {
				gs.close()
				return
			}

			for seen[data] {
				data, ok = gs.getPrevData()
				if !ok {
					gs.close()
					return
				}
			}
			gs.nextData <- data
			seen[data] = true
		}
		gs.close()
	}()

	return gs
}

// Sorted returns a stream consisting of the elements of stream, sorted
// according to natural order.
func Sorted[type T constraints.Ordered](stream Stream[T]) Stream[T] {
	s, ok := stream.(*genericStream[T])
	if !ok {
		panic("type assertion failed")
	}

	prevReq := s.nextReq
	prevData := s.nextData

	var dataSlice []T
	for {
		prevReq <- struct{}{}
		data, ok := <-prevData
		if !ok {
			break
		}
		dataSlice = append(dataSlice, data)
	}
	close(prevReq)

	sort.Slice(dataSlice, func(i, j int) bool {
		return dataSlice[i] < dataSlice[j]
	})

	return StreamFromSlice(dataSlice)
}

// Reduce performs a reduction on the elements of stream, using the provided
// identity, accumulation and combining functions. Note that the accumulator
// function will be executed in parallel with goroutines. The number of
// goroutines is GOMAXPROCS..
func Reduce[type U, T any](
	stream Stream[T],
	identity U,
	accumulator BiFunction[U, T, U],
	combiner BinaryOperator[U],
) U {
	s, ok := stream.(*genericStream[T])
	if !ok {
		panic("type assertion failed")
	}

	prevReq := s.nextReq
	prevData := s.nextData

	gomaxprocs := runtime.GOMAXPROCS(-1)
	results := make(chan U, gomaxprocs)
	var wg sync.WaitGroup
	wg.Add(gomaxprocs)

	for i := 0; i < gomaxprocs; i++ {
		go func() {
			defer wg.Done()

			result := identity
			for {
				prevReq <- struct{}{}
				data, ok := <-prevData
				if !ok {
					break
				}
				result = accumulator(result, data)
			}
			results <- result
		}()
	}
	wg.Wait()

	close(prevReq)
	close(results)

	result := identity
	for r := range results {
		result = combiner(result, r)
	}

	return result
}
