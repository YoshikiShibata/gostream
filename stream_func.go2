// Copyright Â© 2020 Yoshiki Shibata. All rights reserved.

package gostream

import (
	"constraints"
	"fmt"
	"runtime"
	"sort"
	"sync"
)

// Map returns a stream consisting of the results of applying the given
// function to the elements of the given stream.
func Map[type T, R any](stream Stream[T], mapper Function[T, R]) Stream[R] {
	var gs *genericStream[T]

	switch s := stream.(type) {
	case *genericStream[T]:
		gs = s
	default:
		panic(fmt.Sprintf("Unsupported Type: %T", stream))
	}

	nextReq := make(chan struct{})
	nextData := make(chan R)

	go func() {
		for range nextReq {
			gs.nextReq <- struct{}{}
			t, ok := <-gs.nextData
			if !ok {
				close(nextData)
				close(gs.nextReq)
				go func() {
					for range nextReq {
					}
				}()
				return
			}
			r := mapper(t)
			nextData <- r
		}
	}()

	return &genericStream[R]{
		nextReq:  nextReq,
		nextData: nextData,
	}
}

// FlatMap returns a stream consisting of the results of replacing each
// element of stream with the contents of mapped stream produced by applying
// the provided mapping function to each element.
func FlatMap[type T, R](
	stream Stream[T],
	mapper Function[T, Stream[R]],
) Stream[R] {
	panic("not implemented yet")
}

// Returns a sequential ordered stream whose elements are the specified
// values.
func Of[type T any](data ...T) Stream[T] {
	nextReq := make(chan struct{})
	nextData := make(chan T)

	go func() {
		i := 0
		for range nextReq {
			if i == len(data) {
				close(nextData)
				go func() {
					for range nextReq {
					}
				}()
				return
			}
			if i < len(data) {
				nextData <- data[i]
				i++
			}
		}
		close(nextData)
	}()

	return &genericStream[T]{
		nextReq:  nextReq,
		nextData: nextData,
	}
}

// Distinct returns a stream consisting of the distinct elements
// (according to ==) of this stream.
func Distinct[type T comparable](stream Stream[T]) Stream[T] {
	s, ok := stream.(*genericStream[T])
	if !ok {
		panic("type assertion failed")
	}

	gs := &genericStream[T]{
		prevReq:  s.nextReq,
		prevData: s.nextData,
		nextReq:  make(chan struct{}),
		nextData: make(chan T),
	}

	go func() {
		seen := make(map[T]bool)

		for range gs.nextReq {
			data, ok := gs.getPrevData()
			if !ok {
				gs.close()
				return
			}

			for seen[data] {
				data, ok = gs.getPrevData()
				if !ok {
					gs.close()
					return
				}
			}
			gs.nextData <- data
			seen[data] = true
		}
		gs.close()
	}()

	return gs
}

// Sorted returns a stream consisting of the elements of stream, sorted
// according to natural order.
func Sorted[type T constraints.Ordered](stream Stream[T]) Stream[T] {
	s, ok := stream.(*genericStream[T])
	if !ok {
		panic("type assertion failed")
	}

	prevReq := s.nextReq
	prevData := s.nextData

	var dataSlice []T
	for {
		prevReq <- struct{}{}
		data, ok := <-prevData
		if !ok {
			break
		}
		dataSlice = append(dataSlice, data)
	}
	close(prevReq)

	sort.Slice(dataSlice, func(i, j int) bool {
		return dataSlice[i] < dataSlice[j]
	})

	return Of(dataSlice...)
}

// Reduce performs a reduction on the elements of stream, using the provided
// identity, accumulation and combining functions. Note that the accumulator
// function will be executed in parallel with goroutines. The number of
// goroutines is GOMAXPROCS..
func Reduce[type U, T any](
	stream Stream[T],
	identity U,
	accumulator BiFunction[U, T, U],
	combiner BinaryOperator[U],
) U {
	s, ok := stream.(*genericStream[T])
	if !ok {
		panic("type assertion failed")
	}

	prevReq := s.nextReq
	prevData := s.nextData

	gomaxprocs := runtime.GOMAXPROCS(-1)
	results := make(chan U, gomaxprocs)
	var wg sync.WaitGroup
	wg.Add(gomaxprocs)

	for i := 0; i < gomaxprocs; i++ {
		go func() {
			defer wg.Done()

			result := identity
			for {
				prevReq <- struct{}{}
				data, ok := <-prevData
				if !ok {
					break
				}
				result = accumulator(result, data)
			}
			results <- result
		}()
	}
	wg.Wait()

	close(prevReq)
	close(results)

	result := identity
	for r := range results {
		result = combiner(result, r)
	}

	return result
}

// Collect performs mutable reduction opertion on the elements of stream. A
// mutable result is one in which reduced value is a mutable result container
// such as a slice.
func Collect[type R, T any](
	stream Stream[T],
	supplier Supplier[R],
	accumulator BiFunction[R, T, R],
	combiner BiFunction[R, R, R],
) R {
	panic("Not implemented yet")
}

// func CollectByCollector
// TODO: design and implment this function

// func Builder[type T any]() Builder[T]
// TODO: implement this function

// Empty returns an empty Stream
func Empty[type T any]() Stream[T] {
	gs := &genericStream[T]{
		nextReq:  make(chan struct{}),
		nextData: make(chan T),
	}

	go func() {
		for range gs.nextReq {
			// discard all requests
		}
	}()

	close(gs.nextData)
	return gs
}

// func OfNillable[type T any] Stream[T]
// TODO: design and implment this function

// Iterate returns an infinite sequential ordered Stream produces by iterative
// appliation of a function f to an initial element seed, producing a Stream
// consisiting of seed, f(seed), f(f(seed)), etc.
func Iterate[type T any](seed T, f UnaryOperator[T]) Stream[T] {
	gs := &genericStream[T]{
		nextReq:  make(chan struct{}),
		nextData: make(chan T),
	}

	go func() {
		useSeed := true
		nextValue := seed

		for range gs.nextReq {
			if useSeed {
				gs.nextData <- seed
				useSeed = false
			} else {
				nextValue = f(nextValue)
				gs.nextData <- nextValue
			}
		}
		close(gs.nextData)
	}()

	return gs
}
