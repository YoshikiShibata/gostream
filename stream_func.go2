// Copyright Â© 2020 Yoshiki Shibata. All rights reserved.

package gostream

import (
	"constraints"
	"sort"
)

// Distinct returns a stream consisting of the distinct elements
// (according to ==) of this stream.
func Distinct[type T comparable](stream Stream[T]) Stream[T] {
	s, ok := stream.(*genericStream[T])
	if !ok {
		panic("type assertion failed")
	}

	gs := &genericStream[T]{
		prevReq:  s.nextReq,
		prevData: s.nextData,
		nextReq:  make(chan struct{}),
		nextData: make(chan T),
	}

	go func() {
		seen := make(map[T]bool)

		for range gs.nextReq {
			data, ok := gs.getPrevData()
			if !ok {
				gs.close()
				return
			}

			for seen[data] {
				data, ok = gs.getPrevData()
				if !ok {
					gs.close()
					return
				}
			}
			gs.nextData <- data
			seen[data] = true
		}
		gs.close()
	}()

	return gs
}

// Sorted returns a stream consisting of the elements of stream, sorted
// according to natural order.
func Sorted[type T constraints.Ordered](stream Stream[T]) Stream[T] {
	s, ok := stream.(*genericStream[T])
	if !ok {
		panic("type assertion failed")
	}

	prevReq := s.nextReq
	prevData := s.nextData

	var dataSlice []T
	for {
		prevReq <- struct{}{}
		data, ok := <-prevData
		if !ok {
			break
		}
		dataSlice = append(dataSlice, data)
	}
	sort.Slice(dataSlice, func(i, j int) bool {
		return dataSlice[i] < dataSlice[j]
	})

	return StreamFromSlice(dataSlice)
}

// Reduce performs a reduction on the elements of stream, using the provided
// identity, accumulationg and combining functions.
func Reduce[type U, T any](
	stream Stream[T],
	identity U,
	accumulator BiFunction[U, T, U],
	combiner BinaryOperator[U],
) U {
	panic("Not Implemented Yet")
}
