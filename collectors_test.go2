// Copyright © 2020 Yoshiki Shibata. All rights reserved.

package gostream

import (
	"fmt"
	"slices"
	"strconv"
	"strings"
	"testing"
)

func TestCollectors_ToSliceCollector(t *testing.T) {
	defer trace("TestCollectors_ToSliceCollector")()

	data := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}

	result := CollectByCollector(Of(data...), ToSliceCollector[int]())
	if !slices.Equal(result, data) {
		t.Errorf("result is %v, want %v", result, data)
	}
}

func TestCollectors_ToSetCollector(t *testing.T) {
	defer trace("TestCollectors_ToSetCollector")()

	data := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
		1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
		1, 3, 5, 7, 9, 10, 10, 10, 10,
		9, 9, 9, 9, 9, 1, 1, 1, 1, 1}

	result := CollectByCollector(Of(data...), ToSetCollector[int]())
	if len(result) != 10 {
		t.Errorf("len(result) is %d, want 10", len(result))
	}
	want := "map[1:true 2:true 3:true 4:true 5:true 6:true 7:true 8:true 9:true 10:true]"
	resultStr := fmt.Sprintf("%v", result)
	if resultStr != want {
		t.Errorf("resultStr is %q, but want %q", resultStr, want)
	}
}

func TestCollectors_JoiningCollector(t *testing.T) {
	defer trace("TestCollectors_JoinigCollector")()

	data := []string{"hello", "world", "こんにちは", "世界"}
	result := CollectByCollector(Of(data...), JoiningCollector(" "))
	want := strings.Join(data, " ")
	if result != want {
		t.Errorf("result is %q, want %q", result, want)
	}
}

func TestCollectors_MappingCollector(t *testing.T) {
	defer trace("TestCollectors_MappingCollector")()

	data := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
	result := CollectByCollector(Of(data...),
		MappingCollector(
			strconv.Itoa,
			JoiningCollector(" ")))

	want := CollectByCollector(
		Map(Of(data...),
			strconv.Itoa),
		JoiningCollector(" "))

	if result != want {
		t.Errorf("result is %q, want %q", result, want)
	}
}

func TestCollectors_FlatMappingCollector(t *testing.T) {
	defer trace("TestCollectors_FlatMappingCollector")()

	data := []int{0, 10, 20}
	result := CollectByCollector(
		Of(data...),
		FlatMappingCollector(
			func(t int) Stream[string] {
				return Map(
					Iterate(t, func(v int) int { return v + 1 }).Limit(10),
					strconv.Itoa,
				)
			},
			JoiningCollector(" "),
		),
	)

	var data2 []string
	for i := 0; i < 30; i++ {
		data2 = append(data2, strconv.Itoa(i))
	}
	want := strings.Join(data2, " ")

	if result != want {
		t.Errorf("result is %q, want %q", result, want)
	}
}

func TestCollectors_FilteringCollector(t *testing.T) {
	defer trace("TestCollectors_FilteringCollector")()

	data := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}

	result := CollectByCollector(
		Of(data...),
		FilteringCollector(
			func(t int) bool { return t&1 == 0 },
			ToSliceCollector[int](),
		),
	)

	want := []int{2, 4, 6, 8, 10}
	if !slices.Equal(result, want) {
		t.Errorf("result is %v, want %v", result, want)
	}
}

func TestCollectors_GroupingByToSliceCollector(t *testing.T) {
	defer trace("TestCollectors_GroupingByToSliceCollector")()

	data := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
	result := CollectByCollector(
		Of(data...),
		GroupingByToSliceCollector(
			func(t int) string {
				if t&1 == 0 {
					return "even"
				}
				return "odd"
			},
		),
	)
	want := "map[even:[2 4 6 8 10] odd:[1 3 5 7 9]]"
	resultStr := fmt.Sprintf("%v", result)
	if resultStr != want {
		t.Errorf("resultStr is %q, but want %q", resultStr, want)
	}
}

func TestCollectors_GroupingByCollector(t *testing.T) {
	defer trace("TestCollectors_GroupingByCollector")()

	data := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}

	t.Run("Set", func(t *testing.T) {
		defer trace("TestCollectors_GroupingByCollector/Set")()

		result := CollectByCollector(
			Of(data...),
			GroupingByCollector(
				func(t int) string {
					if t&1 == 0 {
						return "even"
					}
					return "odd"
				},
				ToSetCollector[int]()),
		)

		want := "map[even:map[2:true 4:true 6:true 8:true 10:true] odd:map[1:true 3:true 5:true 7:true 9:true]]"
		resultStr := fmt.Sprintf("%v", result)
		if resultStr != want {
			t.Errorf("resultStr is %q, but want %q", resultStr, want)
		}
	})

	t.Run("Slice", func(t *testing.T) {
		defer trace("TestCollectors_GroupingByCollector/Slice")()

		result := CollectByCollector(
			Of(data...),
			GroupingByCollector(
				func(t int) string {
					if t&1 == 0 {
						return "even"
					}
					return "odd"
				},
				ToSliceCollector[int]()),
		)
		want := "map[even:[2 4 6 8 10] odd:[1 3 5 7 9]]"
		resultStr := fmt.Sprintf("%v", result)
		if resultStr != want {
			t.Errorf("resultStr is %q, but want %q", resultStr, want)
		}
	})
}

func TestCollectors_PartitioningByCollector(t *testing.T) {
	defer trace("TestCollectors_PartitioningByCollector")()

	data := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}

	t.Run("Slice", func(t *testing.T) {
		defer trace("TestCollectors_GroupingByCollector/Slice")()

		result := CollectByCollector(
			Of(data...),
			PartitioningByCollector(
				func(t int) bool { return t&1 == 0 },
				ToSliceCollector[int]()),
		)
		want := "map[false:[1 3 5 7 9] true:[2 4 6 8 10]]"
		resultStr := fmt.Sprintf("%v", result)
		if resultStr != want {
			t.Errorf("resultStr is %q, but want %q", resultStr, want)
		}
	})
}
