// Copyright © 2020 Yoshiki Shibata. All rights reserved.

package gostream

import (
	"fmt"
	"slices"
	"sort"
	"strconv"
	"strings"
	"testing"
)

func TestCollectors_ToSliceCollector(t *testing.T) {
	defer trace("TestCollectors_ToSliceCollector")()

	for _, tc := range [...]struct {
		dataSize int
	}{
		{dataSize: 0},
		{dataSize: 1},
		{dataSize: 1000},
	} {

		var data []int
		var want []int
		for i := 0; i < tc.dataSize; i++ {
			data = append(data, i)
			want = append(want, i)
		}

		for _, parallel := range [...]bool{false, true} {
			s := Of(data...)
			if parallel {
				s = s.Parallel()
			}

			result := CollectByCollector(s, ToSliceCollector[int]())
			if parallel {
				sort.Slice(result, func(i, j int) bool {
					return result[i] < result[j]
				})
			}
			if !slices.Equal(result, data) {
				t.Errorf("result is %v, want %v", result, data)
			}
		}
	}
}

func TestCollectors_ToSetCollector(t *testing.T) {
	defer trace("TestCollectors_ToSetCollector")()

	for _, tc := range [...]struct {
		dataSize int
	}{
		{dataSize: 0},
		{dataSize: 1},
		{dataSize: 1000},
	} {

		var data []int
		var want = make(map[int]bool)
		for i := 0; i < tc.dataSize; i++ {
			data = append(data, i, i, i)
			want[i] = true
		}

		for _, parallel := range [...]bool{false, true} {
			s := Of(data...)
			if parallel {
				s = s.Parallel()
			}

			result := CollectByCollector(s, ToSetCollector[int]())
			if len(result) != tc.dataSize {
				t.Errorf("len(result) is %d, want %d", len(result), tc.dataSize)
			}
			for i := 0; i < tc.dataSize; i++ {
				if !result[i] {
					t.Errorf("result[%d] is false, want true", i)
				}
			}
		}

	}
}

func TestCollectors_JoiningCollector(t *testing.T) {
	defer trace("TestCollectors_JoinigCollector")()

	data := []string{"hello", "world", "こんにちは", "世界"}
	result := CollectByCollector(Of(data...), JoiningCollector(" "))
	want := strings.Join(data, " ")
	if result != want {
		t.Errorf("result is %q, want %q", result, want)
	}
}

func TestCollectors_MappingCollector(t *testing.T) {
	defer trace("TestCollectors_MappingCollector")()

	data := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
	result := CollectByCollector(Of(data...),
		MappingCollector(
			strconv.Itoa,
			JoiningCollector(" ")))

	want := CollectByCollector(
		Map(Of(data...),
			strconv.Itoa),
		JoiningCollector(" "))

	if result != want {
		t.Errorf("result is %q, want %q", result, want)
	}
}

func TestCollectors_FlatMappingCollector(t *testing.T) {
	defer trace("TestCollectors_FlatMappingCollector")()

	data := []int{0, 10, 20}
	result := CollectByCollector(
		Of(data...),
		FlatMappingCollector(
			func(t int) Stream[string] {
				return Map(
					Iterate(t, func(v int) int { return v + 1 }).Limit(10),
					strconv.Itoa,
				)
			},
			JoiningCollector(" "),
		),
	)

	var data2 []string
	for i := 0; i < 30; i++ {
		data2 = append(data2, strconv.Itoa(i))
	}
	want := strings.Join(data2, " ")

	if result != want {
		t.Errorf("result is %q, want %q", result, want)
	}
}

func TestCollectors_FilteringCollector(t *testing.T) {
	defer trace("TestCollectors_FilteringCollector")()

	data := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}

	result := CollectByCollector(
		Of(data...),
		FilteringCollector(
			func(t int) bool { return t&1 == 0 },
			ToSliceCollector[int](),
		),
	)

	want := []int{2, 4, 6, 8, 10}
	if !slices.Equal(result, want) {
		t.Errorf("result is %v, want %v", result, want)
	}
}

func TestCollectors_GroupingByToSliceCollector(t *testing.T) {
	defer trace("TestCollectors_GroupingByToSliceCollector")()

	data := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
	result := CollectByCollector(
		Of(data...),
		GroupingByToSliceCollector(
			func(t int) string {
				if t&1 == 0 {
					return "even"
				}
				return "odd"
			},
		),
	)
	want := "map[even:[2 4 6 8 10] odd:[1 3 5 7 9]]"
	resultStr := fmt.Sprintf("%v", result)
	if resultStr != want {
		t.Errorf("resultStr is %q, but want %q", resultStr, want)
	}
}

func TestCollectors_GroupingByCollector(t *testing.T) {
	defer trace("TestCollectors_GroupingByCollector")()

	data := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}

	t.Run("Set", func(t *testing.T) {
		defer trace("TestCollectors_GroupingByCollector/Set")()

		result := CollectByCollector(
			Of(data...),
			GroupingByCollector(
				func(t int) string {
					if t&1 == 0 {
						return "even"
					}
					return "odd"
				},
				ToSetCollector[int]()),
		)

		want := "map[even:map[2:true 4:true 6:true 8:true 10:true] odd:map[1:true 3:true 5:true 7:true 9:true]]"
		resultStr := fmt.Sprintf("%v", result)
		if resultStr != want {
			t.Errorf("resultStr is %q, but want %q", resultStr, want)
		}
	})

	t.Run("Slice", func(t *testing.T) {
		defer trace("TestCollectors_GroupingByCollector/Slice")()

		result := CollectByCollector(
			Of(data...),
			GroupingByCollector(
				func(t int) string {
					if t&1 == 0 {
						return "even"
					}
					return "odd"
				},
				ToSliceCollector[int]()),
		)
		want := "map[even:[2 4 6 8 10] odd:[1 3 5 7 9]]"
		resultStr := fmt.Sprintf("%v", result)
		if resultStr != want {
			t.Errorf("resultStr is %q, but want %q", resultStr, want)
		}
	})
}

func TestCollectors_PartitioningByToSliceCollector(t *testing.T) {
	defer trace("TestCollectors_PartitioningByToSliceCollector")()

	data := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}

	t.Run("Slice", func(t *testing.T) {
		defer trace("TestCollectors_GroupingByCollector/Slice")()

		result := CollectByCollector(
			Of(data...),
			PartitioningByToSliceCollector(
				func(t int) bool { return t&1 == 0 },
			),
		)
		want := "map[false:[1 3 5 7 9] true:[2 4 6 8 10]]"
		resultStr := fmt.Sprintf("%v", result)
		if resultStr != want {
			t.Errorf("resultStr is %q, but want %q", resultStr, want)
		}
	})
}
func TestCollectors_PartitioningByCollector(t *testing.T) {
	defer trace("TestCollectors_PartitioningByCollector")()

	data := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}

	t.Run("Slice", func(t *testing.T) {
		defer trace("TestCollectors_GroupingByCollector/Slice")()

		result := CollectByCollector(
			Of(data...),
			PartitioningByCollector(
				func(t int) bool { return t&1 == 0 },
				ToSliceCollector[int]()),
		)
		want := "map[false:[1 3 5 7 9] true:[2 4 6 8 10]]"
		resultStr := fmt.Sprintf("%v", result)
		if resultStr != want {
			t.Errorf("resultStr is %q, but want %q", resultStr, want)
		}
	})
}

func TestCollectors_ToMapCollector(t *testing.T) {
	defer trace("TestCollectors_ToMapByCollector")()

	data := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}

	result := CollectByCollector(
		Of(data...),
		ToMapCollector(
			func(t int) string {
				if t&1 == 0 {
					return "even"
				}
				return "odd"
			},
			func(t int) int { return t },
			func(v1, v2 int) int { return v1 + v2 },
		),
	)
	evenSum := 2 + 4 + 6 + 8 + 10
	oddSum := 1 + 3 + 5 + 7 + 9
	if result["even"] != evenSum {
		t.Errorf("result[even] is %d, want %d", result["even"], evenSum)
	}
	if result["odd"] != oddSum {
		t.Errorf("result[odd] is %d, want %d", result["odd"], oddSum)
	}
}
