// Copyright Â© 2020 Yoshiki Shibata. All rights reserved.

package gostream

type sliceStream(type T) struct {
	data     []T
	nextReq  chan struct{}
	nextData chan T
}

func newSliceStreamImpl(type T)(data []T) *sliceStream(T) {
	ss := &sliceStream(T){
		data:     data,
		nextReq:  make(chan struct{}),
		nextData: make(chan T),
	}
	go func() {
		i := 0
		for range ss.nextReq {
			if i == len(ss.data) {
				close(ss.nextData)
				return
			}
			if i < len(ss.data) {
				ss.nextData <- ss.data[i]
				i++
			}
		}
		close(ss.nextData)
	}()

	return ss
}

func (ss *sliceStream(T)) Filter(predicate Predicate(T)) Stream(T) {
	gs := &genericStream(T){
		prevReq:  ss.nextReq,
		prevData: ss.nextData,
		nextReq:  make(chan struct{}),
		nextData: make(chan T),
	}
	go gs.filter(predicate)

	return gs
}

func (ss *sliceStream(T)) ForEach(action Consumer(T)) {
	ss.nextReq <- struct{}{}
	for t := range ss.nextData {
		action(t)
		ss.nextReq <- struct{}{}
	}
}

func (ss *sliceStream(T)) Sorted(less Less(T)) Stream(T) {
	panic("Not Implemented Yet")
}

func (ss *sliceStream(T)) Peek(action Consumer(T)) Stream(T) {
	panic("Not Implemented Yet")
}

func (ss *sliceStream(T)) Limit(maxSize int) Stream(T) {
	panic("Not Implemented Yet")
}

func StreamFromSlice(type T)(slice []T) Stream(T) {
	return newSliceStreamImpl(slice)
}
