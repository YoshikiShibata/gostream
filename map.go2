// Copyright Â© 2020 Yoshiki Shibata. All rights reserved.

package gostream

import (
	"fmt"
)

type mapStream(type T) struct {
	nextReq  chan struct{}
	nextData chan T
}

// Map returns a stream consisting of the results of applying the given
// function to the elements of the given stream.
func Map(type T, R)(stream Stream(T), mapper Function(T, R)) Stream(R) {
	var gs *genericStream(T)

	switch s := stream.(type) {
	case *sliceStream(T):
		gs = &genericStream(T){
			prevReq:  nil,
			prevData: nil,
			nextReq:  s.nextReq,
			nextData: s.nextData,
		}
	case *genericStream(T):
		gs = s
	case *mapStream(T):
		gs = &genericStream(T){
			prevReq:  nil,
			prevData: nil,
			nextReq:  s.nextReq,
			nextData: s.nextData,
		}
	default:
		panic(fmt.Sprintf("Unsupported Type: %T", stream))
	}

	ms := &mapStream(R){
		nextReq:  make(chan struct{}),
		nextData: make(chan R),
	}

	go func() {
		for range ms.nextReq {
			gs.nextReq <- struct{}{}
			t, ok := <-gs.nextData
			if !ok {
				close(ms.nextData)
				close(gs.nextReq)
				return
			}
			r := mapper(t)
			ms.nextData <- r
		}
	}()

	return ms
}

func (ms *mapStream(T)) Filter(predicate Predicate(T)) Stream(T) {
	gs := &genericStream(T){
		prevReq:  ms.nextReq,
		prevData: ms.nextData,
		nextReq:  make(chan struct{}),
		nextData: make(chan T),
	}

	go gs.filter(predicate)

	return gs
}

func (ms *mapStream(T)) ForEach(action Consumer(T)) {
	ms.nextReq <- struct{}{}
	for t := range ms.nextData {
		action(t)
		ms.nextReq <- struct{}{}
	}
}

func (ms *mapStream(T)) Sorted(less Less(T)) Stream(T) {
	panic("Not Implemented Yet")
}

func (ms *mapStream(T)) Peek(action Consumer(T)) Stream(T) {
	panic("Not Implemented Yet")
}

func (ms *mapStream(T)) Limit(maxSize int) Stream(T) {
	panic("Not Implemented Yet")
}

// FlatMap returns a stream consisting of the results of replacing each
// element of stream with the contents of mapped stream produced by applying
// the provided mapping function to each element.
func FlatMap(type T, R)(
	stream Stream(T),
	mapper Function(T, Stream(R)),
) Stream(R) {
	panic("not implemented yet")
}
